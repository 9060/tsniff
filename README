ABOUT
=====

tsniff は shell script や MythTV などのフロントエンドに対して、
ハードウェア制御やパフォーマンスクリティカルな処理を行うバックエンドとして
利用することを想定しています。

tsniff そのものに予約などの高度な機能を追加する予定は **全くありません** 。


INSTALL
=======

 libusb-1.0 0499e9f418607b5786ac0c3e97bc46737a609ca3

1. 最新版の snapshot を入手します

 $ wget "http://projects.reactivated.net/cgi-bin/gitweb.cgi?p=libusb.git;a=snapshot;h=0499e9f418607b5786ac0c3e97bc46737a609ca3;sf=tgz"


TODO
====

 * ECM鍵到着と利用の時間差を計測して表示
 * 時間ベースのTS遅延バッファサイズ指定
 * B-CASシステム鍵と初期CBCを設定ファイルに追い出す(配布しない)
 * シグナル受信してクリーンアップに入ったら、シグナルハンドラを削除
 * 終了時の各種バッファのフラッシュ
 * 終了時の各種バッファとインスタンスの解放
 * カードリーダーを使えるようにする
 * 各種入力ソースと動作モードの整理
   * TS ← FX2 / ファイル
   * B-CAS ← FX2 / ファイル / カードリーダー
   * TS → Rawファイル(STDOUT) / Decodedファイル(STDOUT)
   * B-CAS → ファイル(STDOUT)
 * ログをファイルに出力
 * 最初のECM鍵が到着するまでTSをsniffしない? その場合は無効区間をログ出力
 * VLCの input module
 * mplayerの input module
 * EP4INのパケットサイズを可変にする(ファームウェアのパッチ当て)
   * 変更後は、EP4INのパケットサイズをディスクリプタから読んで設定する
 * 使わないけど、なんとなくMacOSXに移植してみる(USB周りだけでいけるはず)
 * 万が一にも気が向けばWindowsに移植してみる
 * Friio対応(実機がない)
   * cap_sts式のほうが機能・運用・コストどれを取ってもメリットが大きいので、あまりやる気なし
 * TSの処理(どこまでやるか?)
